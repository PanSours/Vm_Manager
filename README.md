# Synopsis
This work provides a program that translates logical and physical addresses for a room-sized virtual address 216 = 65.536 bytes (Virtual Memory Manager). The program reads from a file containing logical addresses and, using a TLB (16 seats) and a page table (1 layer), translates each logical address in its corresponding physical address and outputs the value of the byte, stored in the translated physical address. Finally it reads a file containing several integers - logical addresses. The logical addresses are organized as follows: (1) page number and 8 bits (2) offset of the page within 8 bits.

# Background
The program implements paging on demand. The auxiliary storage is implemented by the file BACKING_STORE.bin, a binary file size 65.536 bytes. When a page fault occurs, a page will be read 256 bytes from BACKING_STORE and save it to an available page frame within the physical memory. For example, if a logical address with page number X causes a page fault, the program will read the page X from the BACKING_STORE and store it in a page frame in physical memory. Once saved this context (and update the page table and TLB) subsequent accesses on page X be settled either by the TLB, or from the page table. BACKING_STORE.bin is treated like a random access file. The physical memory has the same size as the page table, so there is no replacement policy in physical memory. The tlb has size 16 and works under LRU replacement policy.

# Running the project
The program was developed and tested in a linux environment. It is compiled with the command make, otherwise gcc -o vm_manager vm_manager.c datatypes.c -lm. Also, to run the program takes one argument, this is  the filename containing the addresses. One possible execution would therefore be: vm_manager addresses.txt
